<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Overview - Introduction to Netidx</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html" class="active"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="small_example.html"><strong aria-hidden="true">2.</strong> Small Example</a></li><li class="chapter-item expanded "><a href="complete_system.html"><strong aria-hidden="true">3.</strong> A Complete System</a></li><li class="chapter-item expanded "><a href="administration.html"><strong aria-hidden="true">4.</strong> Administration</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Introduction to Netidx</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#overview-of-netidx" id="overview-of-netidx">Overview of Netidx</a></h1>
<p>Netidx is a library, protocol, and server that facilitates publishing
the value of a variable in one program and consuming it in another
program, possibly on another computer. There are a lot of details, but
making that transaction as easy as possible, while still being secure
and performant is the essential goal.</p>
<h2><a class="header" href="#the-namespace" id="the-namespace">The Namespace</a></h2>
<p>Netidx values are published to a hierarchical tuple space. The
structure of the names look just like a filename, e.g.</p>
<pre><code>/apps/solar/stats/battery_sense_voltage
</code></pre>
<p>Is an example name. Unlike a file name, a netidx name may point to a
value, and also have children. So keeping the file analogy, it can be
both a file and a directory. For example we might have,</p>
<pre><code>/apps/solar/stats/battery_sense_voltage/millivolts
</code></pre>
<p>Where the <code>.../battery_sense_voltage</code> points to the number in volts,
and it's 'millivolts' child gives the same number in millivolts.</p>
<p>Sometimes a name like <code>battery_sense_voltage</code> is published deep in the
hierarchy and it's parents are just structure. Unlike the file system
the resolver server will create and delete those structural containers
automatically, there is no need to manually manage them.</p>
<p>The term 'points to' is literal. In netidx the actual data is
completely separate from the names. The names are stored in the
resolver server cluster. Each name points to the ip address and port
of the publisher that actually has the data.</p>
<p>When a client wants to subscribe to the value pointed to by a name, it
queries the resolver server cluster, and is given the addresses of all
the publishers that publish said data point. It then randomly permutes
that list, and tries to subscribe to each address. If one of them
succeeds, then the subscription succeeds, if they all fail then it
doesn't. All the actual data flows from publishers to subscribers
directly without ever going through any kind of centralized
infrastructure.</p>
<h2><a class="header" href="#whats-a-value" id="whats-a-value">What's a Value</a></h2>
<p>Values are primitives, e.g. various kinds of number, strings,
durations, timestamps, and byte arrays. Values don't have any inherent
structure, but of course you can use byte arrays to publish anything
that can be serialized, and since byte arrays are zero copy that is
even quite efficient.</p>
<p>Published values have some other properties as well,</p>
<ul>
<li>Every non structural name points to a value</li>
<li>Every new subscription immediately delivers it's most recent value</li>
<li>When a value is updated, every subscriber receives the new value</li>
<li>Updates arrive reliably and in the order the publisher made them
(like a TCP stream)</li>
</ul>
<h2><a class="header" href="#scale" id="scale">Scale</a></h2>
<p>Netidx is meant to be a building block, and as such a lot of thought
has gone into scale. There are multiple different parts of the system
that need to scale. The resolver servers, being the only centralized
piece of infrastructure, are perhaps the most important piece, though
the publisher and subscriber also need to be fast or it won't be worth
using.</p>
<h3><a class="header" href="#resolver-server" id="resolver-server">Resolver Server</a></h3>
<p>The resolver servers implement two strategies to achieve
scale. Replication is the first, one can deploy multiple replicas to
multiple machines in order to protect against a single machine outage,
and also increase throughput. In netidx, the publisher itself is the
primary, and as such it is responsible for replicating the names it
publishes out to all the configured resolver servers. This makes the
system very resilient, as even if the entire resolver server cluster
goes down, the data isn't lost if the publishers are still alive. They
will keep trying to republish their data with linear backoff until
they are killed.</p>
<p>Hierarchy is the second scaling strategy. When a system grows too big
to fit in even a large cluster of servers, then busy parts of the
namespace can be delegated to 'child' server clusters. Readers
familiar with DNS will recognize the basic strategy, though the
details not exactly the same. The administration overhead is similarly
hierarchical, since each cluster config file must only know about it's
immediate superior and immediate children. It's entirely possible for
a large organization to run a central 'root' resolver server cluster
without needing to micro manage the delegation going on in various
organizational units.</p>
<p>I've focused on designing a scaleable architecture, but I should also
mention that the resolver server itself is pretty fast, and uses a
number of strategies to minimize memory use. It's entirely possible to
put 100 million names in a single instance on a single machine with
32 - 64 gig of ram. You get roughly 1 million names per 500 MB of ram,
assuming your paths aren't crazy long. I have not explicitly tested
the resolve throughput, but given that it uses the same infrastructure
as the publisher/subscriber (which I have tested), and what it's
doing, I would not be at all surprised if you could support millions
of resolutions per second per core (yes it will use all your cores).</p>
<h3><a class="header" href="#publishersubscriber" id="publishersubscriber">Publisher/Subscriber</a></h3>
<p>On the wire, the netidx protocol is almost exactly the same as
protobuf. In protobuf, each record is extensible and rather cleverly
encoded. Each field in the record has a LEB128 Id, followed by a data
value.</p>
<p>In netidx, the subscriber sends the name it wants to one of the
publishers specified by the resolver server cluster. The publisher
looks up that value, and responds with the id it will use in
subsequent messages, along with the current value. From then on
updates to that value transmit only the id, which is LEB128 encoded,
and the updated value. So on the wire, in terms of overhead, it looks
very much like a protobuf record where the fields are exactly what the
subscriber has requested and nothing more. The overhead of sending an
f64 can be as small as 2 additional bytes (so 10 in total, 1 id byte,
1 tag byte).</p>
<p>Publisher and subscriber performance is fairly good, such that sending
many millions of messages per second is possible. As of this writing a
fast machine can send about 15 million kerberos encrypted
messages/second and more then 20 million in the clear. The per message
overhead is on the order of about 50ns of wall clock time per message
with kerberos encryption on. Obviously that number depends on the
exact hardware you're running on, and it depends on your workload
batching well.</p>
<p>The subscriber library also implements zero copy decoding for strings
and byte arrays, so it is possible to receive large binary encoded
things quite efficiently.</p>
<h2><a class="header" href="#security" id="security">Security</a></h2>
<p>No system like netidx can be taken seriously without a plausible
design for securing data against unauthorized access, interception,
manipulation, etc.</p>
<p>The heart of netidx security is Kerberos v5. There are a lot of
systems I might have used, e.g. openssl + certificates, oauth +
openssl, and I'm sure many others. The reason I chose to use Kerberos
v5 is that most users who I think might want to deploy netidx services
already have Kerberos set up (even if they don't know it) in the form
of Microsoft Active Directory, Samba ADS, Redhat Directory Server, or
one of the many other compatible solutions.</p>
<p>That said security is optional in netidx. It's possible to deploy a
netidx system with no security at all, and it's possible to deploy a
system where some publishers require security, and some do not. While
it's possible to mix secured and non secured publishers on the same
resolver cluster there are some restrictions. </p>
<ul>
<li>If a subscriber is configured with security, then it won't talk to
publishers that aren't.</li>
<li>If a publisher is configured with security, then it won't talk to a
subscriber that isn't.</li>
</ul>
<p>When security is enabled you get the following guarantees,</p>
<ul>
<li>
<p><strong>Mutual Authentication</strong>, the publisher knows the subscriber is who
they claim to be, and the subscriber knows the publisher is who they
claim to be. This applies for the resolver &lt;-&gt; subscriber, and
resolver &lt;-&gt; publisher as well.</p>
</li>
<li>
<p><strong>Confidentiality</strong> and Tamper detection, all messages are encrypted,
and data cannot be altered undetected by a man in the middle.</p>
</li>
<li>
<p><strong>Authorization</strong>, The user subscribing to a given data value is
authorized to do so. The resolver servers maintain a permissions
database specifying who is allowed to do what where in the
tree. Thus the system administrator can centrally control who is
allowed to publish and subscribe where.</p>
</li>
</ul>
<h2><a class="header" href="#subscription-flow" id="subscription-flow">Subscription Flow</a></h2>
<h3><a class="header" href="#components" id="components">Components</a></h3>
<p><img src="subscription-flow-components.png" alt="The Components" /></p>
<p>In the full kerberos enabled version of netidx the following
components are involved.</p>
<ul>
<li>The Kerberos 5 KDC (Key Distribution Center). e.g. The AD Domain Controller.</li>
<li>Resolver Cluster, holds the path of everything published and the
address of the publisher publishing it.</li>
<li>Subscriber</li>
<li>Publisher, holds the actual data, and has previously told the
resolver server about the path of all the data it has.</li>
</ul>
<h3><a class="header" href="#step-1" id="step-1">Step 1</a></h3>
<p><img src="subscription-flow-step1.png" alt="First Step" /></p>
<ol>
<li>The Subscriber asks the KDC for a service ticket to talk to the
Resolver Cluster. Note this only happens once for each user for
some amount of time (usually hours), after which the service ticket
is cached. The subscriber proves it's identity to the KDC using
it's TGT.</li>
<li>The KDC, having checked the validity of the subscriber's identity,
generates a service ticket for the resolver server cluster. NOTE,
Kerberos does not make authorization decisions, it merely allows
entities to prove to each other that they are who they claim to be.</li>
</ol>
<h3><a class="header" href="#step-2" id="step-2">Step 2</a></h3>
<p><img src="subscription-flow-step2.png" alt="Second Step" /></p>
<ol start="3">
<li>The Subscriber uses the service ticket to establish an encrypted
GSSAPI session with the Resolver Cluster.</li>
<li>Using the session it just established sends a resolve request for
the paths it wants to subscribe to. All traffic is encrypted using
the session.</li>
<li>The Resolver Cluster verifies the presented GSSAPI token and
establishes a secure session, looks up the requested paths, and
returns a number of things to the subscriber for each path.
<ul>
<li>The addresses of all the publishers who are publishing that path</li>
<li>The service principal names of those publishers</li>
<li>The permissions the subscriber has to the path</li>
<li>The authorization token, which is a SHA512 hash of the concatenation of
<ul>
<li>A secret shared by the Resolver Cluster and the Publisher</li>
<li>The path</li>
<li>The permissions</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3><a class="header" href="#step-3" id="step-3">Step 3</a></h3>
<p><img src="subscription-flow-step3.png" alt="Third Step" /></p>
<ol start="6">
<li>The subscriber picks a random publisher from the set of publishers
publishing the path it wants, and requests a service ticket for
that publisher's SPN from the KDC.</li>
<li>The KDC validates the subscriber's TGT and returns a service ticket
for the requested SPN, which will be cached going forward (usually
for several hours).</li>
</ol>
<h3><a class="header" href="#step-4" id="step-4">Step 4</a></h3>
<p><img src="subscription-flow-step4.png" alt="Fourth Step" /></p>
<ol start="8">
<li>
<p>The subscriber uses the service ticket it just obtained to
establish an encrypted GSSAPI session with the publisher, and using
this session it sends a subscribe request, which consists of,</p>
<ul>
<li>The path it wants to subscribe to</li>
<li>The permissions the resolver cluster gave to it</li>
<li>The authorization token</li>
</ul>
</li>
<li>
<p>The publisher validates the subscriber's GSSAPI token and
establishes an encrypted session, and then reads the subscribe
request. It looks up the request path, and assuming it is
publishing that path, it constructs a SHA512 hash value of,</p>
<ul>
<li>The secret it shared with the resolver cluster when it initially
published the path.</li>
<li>The path the subscriber is requesting</li>
<li>The permissions the subscriber claims to have </li>
</ul>
<p>It then checks that it's constructed auth token matches the one the
subscriber presented. Since the subscriber does not know the secret
the publisher shared with the resolver server it is computationally
infeasible for the subscriber to generate a valid hash value for an
arbitrary path or permissions, therefore checking this hash is an
effective proof that the resolver cluster really gave the
subscriber the permissions it is claiming to have.</p>
<p>Assuming all the authentication and authorization checks out, and
the publisher actually publishes the requested value, it sends the
current value back to the publisher along with the ID of the
subscription.</p>
<p>Whenever the value changes the publisher sends the new value along
with the ID of the subscription to the publisher (encrypted using
the GSSAPI session, and over the same TCP session that was
established earlier).</p>
</li>
</ol>
<p>In the case netidx is not configured to use kerberos the KDC is not
involved, and none of the authentication or authorization tokens are
established/sent, it's just a simple matter of look up the address
from the resolver, and then subscribe to the publisher. In that case
all data goes in the clear.</p>
<h2><a class="header" href="#cross-platform" id="cross-platform">Cross Platform</a></h2>
<p>While netidx is primarily developed on Linux, it has been tested on
Windows, and even Mac OS. It will probably work on many platforms I
haven't tried.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        
                            <a rel="next" href="small_example.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
                    <a rel="next" href="small_example.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
