<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A Complete System - Introduction to Netidx</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="small_example.html"><strong aria-hidden="true">2.</strong> Small Example</a></li><li class="chapter-item expanded "><a href="complete_system.html" class="active"><strong aria-hidden="true">3.</strong> A Complete System</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Introduction to Netidx</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#a-complete-system" id="a-complete-system">A Complete System</a></h1>
<p>In the last chapter we added netidx publishing of one data point to an
existing system, and then explored what we could do with the data. In
this chapter we're going to look at a system designed from scratch to
use netidx as it's primary means of communication and control.</p>
<p>The system we're going to look at is the control program of an off the
grid solar generator. This is a medium sized system, meant to provide
backup power in the event of a long outage, as well as power to any
110vac appliance (up to 20 amps). It consists of a Morningstar
Prostart MPPT charge controller, 4 100 Watt solar panels, 4 lithium
ion batteries arranged in series/parallel to make a 24 volt nominal
200 ah battery pack (about 4.8 Kwh of total storage), and a 3000 Watt
inverter. As the power is quite reliable where I live I often use it
to charge my plug in hybrid car. The Prostar MPPT controller has a
serial port over which it talks modbus, and I've connected a raspberry
pi 3 running bog standard raspbian to that port using a usb to serial
adapter. The pi, called &quot;solar&quot;, is connected to my wifi network and
is joined to my samba ADS domain.</p>
<p>The control program, then, is more or less a simple translation layer
between the modbus interface of the Prostar and netidx. This system
has been around for a long time, predating having netidx working as an
open source system (the closed version goes back over a decade, but
for various reasons it will likely never be released), as such there
is a vestigal web gui, and a local control socket interface (which is
still used by command line tools). Full source code
<a href="https://github.com/estokes/solar">here</a>.</p>
<p>The main loop takes commands from either the command socket, or the
netidx publisher, and sends them via modbus to the charge controller, e.g.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    loop {
        let msg = select_biased! {
            _ = tick.next() =&gt; ToMainLoop::Tick,
            m = receiver.next() =&gt; match m {
                None =&gt; break,
                Some(m) =&gt; m
            }
        };
        debug!(&quot;run_server: {:?}&quot;, msg);
        match msg {
            ToMainLoop::FromClient(msg, mut reply) =&gt; match msg {
                FromClient::SetCharging(b) =&gt; {
                    send_reply(mb.write_coil(ps::Coil::ChargeDisconnect, !b).await, reply)
                        .await
                }
                FromClient::SetLoad(b) =&gt; {
                    send_reply(mb.write_coil(ps::Coil::LoadDisconnect, !b).await, reply)
                        .await
                }
                FromClient::ResetController =&gt; {
                    send_reply(mb.write_coil(ps::Coil::ResetControl, true).await, reply)
                        .await
                }
                FromClient::LogRotated =&gt; {
                    log = log_fatal!(
                        open_log(&amp;config).await,
                        &quot;failed to open log {}&quot;,
                        break
                    );
                    send_reply(Ok(()), reply).await
                }
                FromClient::TailStats =&gt; tailing.push(reply),
                ...
<span class="boring">}
</span></code></pre></pre>
<p>A message is either a timer Tick, on which we send out (and log)
updated stats, or an actual command, which we handle individually. The
publisher module is fed a new stats record read from modbus on each
timer tick. e.g.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn update(&amp;self, st: &amp;Stats) {
        use chrono::prelude::*;
        self.timestamp
            .update_changed(Value::DateTime(DateTime::&lt;Utc&gt;::from(st.timestamp)));
        self.software_version.update_changed(Value::V32(st.software_version as u32));
        self.battery_voltage_settings_multiplier
            .update(Value::V32(st.battery_voltage_settings_multiplier as u32));
        self.supply_3v3.update_changed(Value::F32(st.supply_3v3.get::&lt;volt&gt;()));
        self.supply_12v.update_changed(Value::F32(st.supply_12v.get::&lt;volt&gt;()));
        self.supply_5v.update_changed(Value::F32(st.supply_5v.get::&lt;volt&gt;()));
        self.gate_drive_voltage
            .update_changed(Value::F32(st.gate_drive_voltage.get::&lt;volt&gt;()));
        self.battery_terminal_voltage
            .update_changed(Value::F32(st.battery_terminal_voltage.get::&lt;volt&gt;()));
    ...
<span class="boring">}
</span></code></pre></pre>
<p>These are all published under <code>/solar/stats</code>, there are a lot of them,
so I won't show them all here, you can read the full source if you're
curious. Essentially it's an infinite loop of read stats from modbus,
log to a file, update netidx, flush netidx, loop.</p>
<h2><a class="header" href="#what-about-control" id="what-about-control">What About Control</a></h2>
<p>The above handles distributing the stats perfectly well, but for
control we need some way to send commands from the subscriber back to
the publisher, and that's where writes come in. If you've read the api
documentation you might have noticed,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn write(&amp;self, v: Value)
<span class="boring">}
</span></code></pre></pre>
<p>Continuing with the metaphor of exporting variables to a cross machine
global namespace, it fits perfectly well to imagine that we can write
to those variables as well as read from them, publisher willing.</p>
<p>Our program is going to publish three values for control,
<code>/solar/control/charging</code> (to control whether we are charging the
batteries), <code>/solar/control/load</code> (to control whether the inverter is on
or off), and <code>/solar/control/reset</code> (to trigger a controller
reset). These values will all be boolean, and they will be valid for
both read and write. Here is the full code of the control section,</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PublishedControl {
    charging: Val,
    load: Val,
    reset: Val,
}

impl PublishedControl {
    fn new(publisher: &amp;Publisher, base: &amp;Path) -&gt; Result&lt;Self&gt; {
        Ok(PublishedControl {
            charging: publisher.publish(base.append(&quot;charging&quot;), Value::Null)?,
            load: publisher.publish(base.append(&quot;load&quot;), Value::Null)?,
            reset: publisher.publish(base.append(&quot;reset&quot;), Value::Null)?,
        })
    }

    fn update(&amp;self, st: &amp;Stats) {
        self.charging.update_changed(match st.charge_state {
            ChargeState::Disconnect | ChargeState::Fault =&gt; Value::False,
            ChargeState::UnknownState(_)
            | ChargeState::Absorption
            | ChargeState::BulkMPPT
            | ChargeState::Equalize
            | ChargeState::Fixed
            | ChargeState::Float
            | ChargeState::Night
            | ChargeState::NightCheck
            | ChargeState::Start
            | ChargeState::Slave =&gt; Value::True,
        });
        self.load.update_changed(match st.load_state {
            LoadState::Disconnect | LoadState::Fault | LoadState::LVD =&gt; Value::False,
            LoadState::LVDWarning
            | LoadState::Normal
            | LoadState::NormalOff
            | LoadState::NotUsed
            | LoadState::Override
            | LoadState::Start
            | LoadState::Unknown(_) =&gt; Value::True,
        });
    }

    fn register_writable(&amp;self, channel: fmpsc::Sender&lt;Pooled&lt;Vec&lt;WriteRequest&gt;&gt;&gt;) {
        self.charging.writes(channel.clone());
        self.load.writes(channel.clone());
        self.reset.writes(channel.clone());
    }

    fn process_writes(&amp;self, mut batch: Pooled&lt;Vec&lt;WriteRequest&gt;&gt;) -&gt; Vec&lt;FromClient&gt; {
        batch
            .drain(..)
            .filter_map(|r| {
                if r.id == self.charging.id() {
                    Some(FromClient::SetCharging(bool!(r)))
                } else if r.id == self.load.id() {
                    Some(FromClient::SetLoad(bool!(r)))
                } else if r.id == self.reset.id() {
                    Some(FromClient::ResetController)
                } else {
                    let m = format!(&quot;control id {:?} not recognized&quot;, r.id);
                    warn!(&quot;{}&quot;, &amp;m);
                    if let Some(reply) = r.send_result {
                        reply.send(Value::Error(Chars::from(m)));
                    }
                    None
                }
            })
            .collect()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In process_writes we translate each WriteRequest that is targeted at
one of the published controls into a FromClient message that the main
loop will act on. So from the main loop's perspective it doesn't
matter if a command came from netidx, or a command line tool. Note
that it isn't necessary to do any authorization here, the publisher
library has already checked that the resolver server granted the user
making these writes permission to do them.</p>
<p>For the basic day to day use case, that's all we need on the server
side. The entire daemon uses 6.5 MB or ram, and almost no cpu, it
could certianly run on a smaller device, though we depend on tokio,
which means we at least need a real OS under us (for now).</p>
<p>The kerberos configuration for this service is also quite simple,
there is a service principal called svc_solar in samba ADS, and solar
has a keytab installed for it, as well as a cron job that renews it's
TGT every couple of hours. Depending on which OS and KDC you are using
there are different ways you might do this, but that's pretty far out
of our scope.</p>
<h2><a class="header" href="#building-a-custom-gui-with-views" id="building-a-custom-gui-with-views">Building a Custom GUI With Views</a></h2>
<p>What we have is fine as far as it goes, we can view our stats in
vector mode in the browser, and we can write to the controls using the
command line subscriber. For scripting it's great, but when I want to
turn on the inverter on so I can charge the lawn mower, typing
commands at my phone is not ideal, I'd like a gui. This is where
custom browser views come in, here is the finished product,</p>
<p><img src="solar-gui.png" alt="Solar GUI" /></p>
<p>A view definition can be published to the special value .view in a
given directory (e.g. <code>/solar/.view</code>) so it will automatically render
whenever the browser visits that directory, that's what we've done
here. In fact we have our view definition in a file solar.view, and
we're publishing it with the following shell script,</p>
<pre><code class="language-bash">netidx publisher -b 192.168.0.0/24 --spn svc/host@REALM &lt;&lt;EOF
/solar/.view|string|$(cat ~/solar.view)
EOF

</code></pre>
<p>This need not be on the same machine as the control program, as long
as the user running the command has permission to publish under <code>/solar</code>
it will work.</p>
<p>Building the view in the first place can be done using design mode in
the browser, the view can then be saved to a file or written directly
to a netidx path.</p>
<p><img src="browser-design-mode.png" alt="Browser Design Mode" /></p>
<p>Design mode can be activated at any time with the toggle button in the
upper left corner, to the left of save. It splits the window
vertically into two panes, the gui on the right, and the view
definition on the left. The view definition is visualized as a tree of
widgets, with parents higher in the tree containing children, and each
widget having a type. Notice that we've selected a toggle widget in
the tree, and we can see that widget is highlighted blue in the gui,
as we move the selection, the highlight will move, such that we always
know what part of the actual gui we are changing. From a static
picture it's not possible to see this, however the gui is fully
functional in every way while design mode is activated, it isn't some
&quot;special&quot; mode, what you see is exactly what you will get. This
extends to changes, as we make changes the gui will reflect them
immediatly, of course if we don't like a change we can simply press
the undo button in the tool bar above the widget tree. </p>
<p>Now lets take a look at the bottom part of the view definition pane,
we see the details of the widget we've selected, the toggle button. We
see there are some layout properties hidden by an expander, every
drawable widget has those, so lets leave them for later. Every widget
that does something in the browser has one or more sources, and one or
more sinks. Sources are where data comes in, and sinks are where data
goes out. Sources are defined in a little domain specific language
called the formula language, which will be specified in detail
later. Sinks use the same syntax but have a different set of
functions.</p>
<p>The semantics of the formula language, and it's syntax, are meant to
be very similar to formulas in a spreadsheet. Where instead of row/col
notation, we use netidx paths to denote refs to other parts of the
sheet. Sources update whenever something they ref updates, and sinks
are updated, and may cause sources to update. And, that's all rather
abstract, lets focus on our example.</p>
<p>Our toggle has two sources, and one sink. The enabled source just
determines if the toggle is interactable, and in our case it's set to
a function <code>constant(bool, true)</code>, which creates a source that always
evaluates to <code>Value::True</code>. The other source, just called source,
determines whether the toggle displays as on or off, and this one is
set to <code>load_path(&quot;/solar/control/charging&quot;)</code>, load_path is a function
that creates a source that subscribes to the netidx path it's given
and updates when the subscription updates. So this straightforwardly
ties the state of the toggle to the value of <code>/solar/control/charging</code>,
when that value changes the toggle state changes. When the user clicks
the toggle, either true or false is written to the sink which is
defined as <code>confirm(store_path(&quot;/solar/control/charging&quot;))</code>. So what
does this do?  Well, store_path pretty obviously creates a sink that
writes whatever value it receives to the specified path, confirm is
more complex. It takes a sink as an argument, and returns a sink that
asks the user to confirm every value it receives. If the user says
yes, then it passes the value on to the passed in sink, in this case
to load_path, otherwise it drops the value.</p>
<p>There are many other useful formulas, and the goal is to make building
simple guis like this dead easy, the majority of the work should be
the layout, and moderatly complex guis should be possible. While this
system is already pretty useful it is still under heavy development,
and is by no means finished. Another &quot;limitation&quot; to mention is since
it's built with Gtk+ in Rust it's primarially a desktop application,
though I have tested it on the pinephone under phosh, and even made a
few changes to improve touch support. I will test it on the librem 5
when mine arrives, and it's on my list to build it on windows and
MacOS. Android, and especially iOS versions will not happen, unless
someone else wants to step up.</p>
<h2><a class="header" href="#wrapping-up" id="wrapping-up">Wrapping Up</a></h2>
<p>In this chapter we saw how an application can be designed more or less
from the start to communicate with the outside world using netidx. We
didn't cover the opportunities for scripting our solar installation
now that we can control it using netidx, but we certainly could do any
of the nice things we did in the last chapter. Instead we saw how we
could build a pretty nice looking and functional gui using browser
custom views, and we got an introduction to the formula language. I
want to point out that with our design having a gui in no way alters
our ability to script and manipulate the system programatically.  It's
important to recognize that building a bespoke system with a gui as
complex as the browser view we built AND making it scriptable over the
network in a discoverable, secure, and performant way is not an easy
task, and usually isn't worth doing. However by using netidx we got it
all for free, all we had to do was make our problem fit into netidxs'
data model.</p>
<p>One day I was reflecting on the browser after I had been working on it
for many weeks, and it occurred to me that it is essentially
implementing a distributed verion of the model view controller
paradigm. The netidx data model is the model, the view is the widget
tree and the layout properties, and the controller is the formula
language expressions embedded in each widget. However in this version
of MVC we get to reuse the model over the network, and it need not
even run on the same computer, and I think that's pretty cool.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="small_example.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="small_example.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
