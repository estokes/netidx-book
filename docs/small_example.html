<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Small Example - Introduction to Netidx</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="small_example.html" class="active"><strong aria-hidden="true">2.</strong> Small Example</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Introduction to Netidx</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#a-small-example" id="a-small-example">A Small Example</a></h1>
<p>Suppose we have a small daemon that we run on many computers on our
network, and it knows many things about them, and does many things. I
won't specifiy exactly what it does or everything it knows because
that's irrelevant to the example. However suppose one of the things it
knows is the current CPU temperature of the machine it's running on,
and we would like access to that data. We heard about this new netidx
thing, and we'd like to try it out on this small and not very
important case, what code do we need to add to our daemon, and what
options do we have for using the data?</p>
<p>We can modify our Cargo.toml to include netidx, and then add a small
self contained module, publisher.rs</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use anyhow::Result;
use netidx::{
    config::Config,
    path::Path,
    publisher::{Publisher, Val, Value},
    resolver::Auth,
};

#[derive(Clone)]
pub struct HwPub {
    publisher: Publisher,
    cpu_temp: Val,
}

impl HwPub {
    pub async fn new(host: &amp;str, current: f64) -&gt; Result&lt;HwPub&gt; {
        // load the site cluster config from the path in the
        // environment variable NETIDX_CFG, or from
        // dirs::config_dir()/netidx.json if the environment variable
        // isn't specified, or from ~/.netidx.json if the previous
        // file isn't present. Note this uses the cross platform dirs
        // library, so yes, it does something reasonable on windows.
        let cfg = Config::load_default()?;

        // for this small service we don't need authentication
        let auth = Auth::Anonymous;

        // listen on any unique address matching 192.168.0.0/16. If
        // our network was large and complex we might need to make
        // this a passed in configuration option, but lets assume it's
        // simple.
        let publisher = Publisher::new(cfg, auth, &quot;192.168.0.0/24&quot;.parse()?).await?;

        // We're publishing stats about hardware here, so lets put it
        // in /hw/hostname/cpu-temp, that way we keep everything nice
        // and organized.
        let path = Path::from(format!(&quot;/hw/{}/cpu-temp&quot;, host));
        let cpu_temp = publisher.publish(path, Value::F64(current))?;
        Ok(HwPub {
            publisher,
            cpu_temp,
        })
    }

    pub async fn update(&amp;self, current: f64) -&gt; Result&lt;()&gt; {
        // update the current cpu-temp
        self.cpu_temp.update(Value::F64(current));

        // flush the updated values out to subscribers
        self.publisher.flush(None).await
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now all we would need to do is create a HwPub on startup, and call
HwPub::update whenever we learn about a new cpu temperature value. Of
course we also need to deploy a resolver server, and distribute a
cluster config to each machine that needs one, that will be covered in
the administration section.</p>
<h2><a class="header" href="#using-the-data-we-just-published" id="using-the-data-we-just-published">Using the Data We Just Published</a></h2>
<p>So now that we have our data in netidx, what are our options for
consuming it? The first option, and often a very good one for a lot of
applications is the shell. The netidx command line tools are designed
to make this interaction easy, here's an example of how we might use
the data.</p>
<pre><code class="language-bash">#! /bin/bash

netidx subscriber $(netidx resolver list /hw/ | grep 'cpu-temp$') | \
while IFS='|' read path typ temp; do
    IFS='/' read -a pparts &lt;&lt;&lt; &quot;$path&quot;
    if ((temp &gt; 75)); then
        echo &quot;host: ${pparts[2]} cpu tmp is too high: ${temp}&quot;
    fi
done
</code></pre>
<p>Of course we can hook any logic we want into this, the shell is a very
powerful tool after all. For example one thing we might want do is
modify this script slightly, filter the entries with cpu temps that
are too high, and then publish the temperature and the timestamp when
it was observed.</p>
<pre><code class="language-bash">#! /bin/bash

netidx subscriber $(netidx resolver list /hw/ | grep 'cpu-temp$') | \
while IFS='|' read path typ temp; do
    IFS='/' read -a pparts &lt;&lt;&lt; &quot;$path&quot;
    if ((temp &gt; 75)); then
        echo &quot;/hw/${pparts[2]}/overtemp-ts|string|$(date)&quot;
        echo &quot;/hw/${pparts[2]}/overtemp/temp|f64|$temp&quot;
    fi
done | \
netidx publisher --bind 192.168.0.0/24
</code></pre>
<p>Now we've done something very interesting, we took some data out of
netidx, did a computation on it, and published the result into the
same namespace. We can now subscribe to e.g. /hw/krusty/overtemp-ts
and we will know when that machine last went over temperature. To a
user looking at this namespace in the browser (more on that later)
there is no indication that the over temp data comes from a separate
process, on a separate machine, written by a separate person. It all
just fits together seamlessly as if it was one application.</p>
<p>There is actually a problem here, in that, the above code will not do
quite what you might want it to do. Someone might, for example, want
to write the following additional script.</p>
<pre><code class="language-bash">#! /bin/bash

netidx subscriber $(netidx resolver list /hw/ | grep 'overtemp-ts$') | \
while IFS='|' read path typ temp; do
    IFS='/' read -a pparts &lt;&lt;&lt; &quot;$path&quot;
    ring-very-loud-alarm ${pparts[2]}
done
</code></pre>
<p>To ring a very loud alarm when an over temp event is detected. This
would in fact work, it just would not be as timely as the author might
expect. The reason is that the subscriber practices linear backoff
when it's instructed to subscribe to a path that doesn't exist. This
is a good practice, in general it reduces the cost of mistakes on the
entire system, but in this case it could result in getting the alarm
minutes, hours, or longer after you should. The good news is there is
a simple solution, we just need to publish all the paths from the
start, but fill them will null until the event actually happens (and
change the above code to ignore the null). That way the subscription
will be successful right away, and the alarm will sound immediatly
after the event is detected. So lets change the code ...</p>
<pre><code class="language-bash">#! /bin/bash

cat &lt;(
    netidx resolver list /hw | \
        while IFS='/' read -a pparts
        do
            echo &quot;/hw/${pparts[2]}/overtemp-ts|string|null&quot;
            echo &quot;/hw/${pparts[2]}/overtemp|string|null&quot;
        done
) \
&lt;(
   netidx subscriber $(netidx resolver list /hw/ | grep 'cpu-temp$') | \
       while IFS='|' read path typ temp
       do
            IFS='/' read -a pparts &lt;&lt;&lt; &quot;$path&quot;
            if ((temp &gt; 75)); then
                echo &quot;/hw/${pparts[2]}/overtemp-ts|string|$(date)&quot;
                echo &quot;/hw/${pparts[2]}/overtemp/temp|f64|$temp&quot;
            fi
       done
) | netidx publisher --bind 192.168.0.0/24

</code></pre>
<p>So first we list all the machines in /hw and publish null for
overtemp-ts and overtemp for each one, and then using cat and the
magic of process substitution we append to that the real time list of
actual over temp events.</p>
<h2><a class="header" href="#or-maybe-shell-is-not-your-jam" id="or-maybe-shell-is-not-your-jam">Or Maybe Shell is Not Your Jam</a></h2>
<p>It's entirely possible that thinking about the above solution makes
you shiver and reinforces for you that nothing should ever be written
in shell. In that case it's perfectly possible to do the same thing in
rust.</p>
<pre><pre class="playground"><code class="language-rust">use anyhow::Result;
use futures::{channel::mpsc::channel, prelude::* };
use netidx::{
    config::Config,
    path::Path,
    publisher::{self, Publisher, Value},
    resolver::Auth,
    subscriber::{self, Event, SubId, Subscriber},
};
use chrono::prelude::*;
use std::collections::HashMap;

#[tokio::main]
pub async fn main() -&gt; Result&lt;()&gt; {
    let config = Config::load_default()?;
    let auth = Auth::Anonymous;
    let subscriber = Subscriber::new(config.clone(), auth.clone())?;
    let publisher = Publisher::new(config, auth, &quot;192.168.0.0/24&quot;.parse()?).await?;
    let (tx_current, mut rx_current) = channel(3);
    struct Temp {
        _current: subscriber::Dval, // we need to hang onto this reference
        timestamp: publisher::Val,
        temperature: publisher::Val,
    }
    let temps = subscriber
        .resolver()
        .list(Path::from(&quot;/hw&quot;))
        .await?
        .drain(..)
        .filter_map(|path| path.split('/').nth(2).map(String::from))
        .map(|host| {
            let current = subscriber
                .durable_subscribe(Path::from(format!(&quot;/hw/{}/cpu-temp&quot;, host)));
            current.updates(true, tx_current.clone());
            let timestamp = publisher
                .publish(Path::from(format!(&quot;/hw/{}/overtemp-ts&quot;, host)), Value::Null)?;
            let temperature = publisher
                .publish(Path::from(format!(&quot;/hw/{}/overtemp&quot;, host)), Value::Null)?;
            Ok((current.id(), Temp { _current: current, timestamp, temperature }))
        })
        .collect::&lt;Result&lt;HashMap&lt;SubId, Temp&gt;&gt;&gt;()?;
    publisher.flush(None).await?;
    while let Some(mut batch) = rx_current.next().await {
        for (id, ev) in batch.drain(..) {
            match ev {
                Event::Unsubscribed =&gt; (), // Subscriber will resubscribe automatically
                Event::Update(v) =&gt; {
                    if let Some(temp) = v.cast_f64() {
                        if temp &gt; 75. {
                            let tr = &amp;temps[&amp;id];
                            tr.timestamp.update(Value::DateTime(Utc::now()));
                            tr.temperature.update(Value::F64(temp));
                        }
                    }
                }
            }
        }
        publisher.flush(None).await?
    }
    Ok(())
}
</code></pre></pre>
<p>This does almost exactly the same thing as the shell script, the only
semantic difference being that it sends an actual DateTime value for
the timestamp instead of a string, which would certainly make life
easier for anyone using this data, not to mention it's more
efficient. There is a little more setup and book keeping, but at 62
lines it's hardly a massive program (and it's nearly 20% use
statements).</p>
<h2><a class="header" href="#but-i-just-want-to-look-at-it" id="but-i-just-want-to-look-at-it">But I Just Want to Look at It</a></h2>
<p>Up to now we've covered using the data in various kinds of programs,
but what if you just want to look at it. For that you have two
choices, you can write a custom tool that presents your data exactly
the way you want, or you can use the netidx browser. A custom tool
will always give you more control, but the browser is designed to be
pretty flexible, and it allows you to get to an ok looking solution
really fast. In the case of the data we've been discussing in this
chapter, you get something pretty nice to look at without doing
anything at all.</p>
<p><img src="small-example-table.png" alt="The Browser rendering a table" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="overview.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="overview.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
